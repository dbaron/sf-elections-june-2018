<!DOCTYPE HTML>
<meta charset=UTF-8>
<title>Election Results, San Francisco, June 2018</title>
<!--
Copyright 2018 L. David Baron

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
-->
<style>

body { background: white; color: black; }

table.rcv_results { border-collapse: collapse; border-width: 2px; }
table.rcv_results > tbody > tr > td.leader { background: #bfb; }
table.rcv_results > tbody > tr > td.winner { background: #7f7; }
table.rcv_results > tbody > tr > td.bubble { background: #fbb; }

table.rcv_results > tbody > tr > td,
table.rcv_results > tbody > tr > th { border: 1px solid black }
table.rcv_results > tbody > tr > td.votes { border-left-width: 2px; border-right-color: gray; }
table.rcv_results > tbody > tr > td.percent { border-right-width: 2px; border-left-color: gray; }
table.rcv_results > tbody > tr > th.total { border-left-width: 2px; border-right-width: 2px; }

table.rcv_results > tbody > tr > th.candidate-removed { font-weight: normal; text-decoration: line-through; }

table.transfers { border-collapse: collapse; border-width: 2px; }
table.transfers > tbody > tr > td,
table.transfers > tbody > tr > th { border: 1px solid black }

table.rcv_results > tbody > tr > td.hover,
table.rcv_results > tbody > tr > th.hover { background: yellow; }
table.rcv_results > tbody > tr > td.selected,
table.rcv_results > tbody > tr > th.selected { background: aqua; }

div.filter {
    display: inline-block;
    vertical-align: top;
    margin: 0.5em;
    padding: 0.5em;
    border: 1px solid;
}

div.transfer {
    display: inline-block;
    vertical-align: top;
    margin: 0.5em;
    padding: 0.5em;
    border: 1px solid;
}

object#map {
    width: 100%;
}

</style>
<script>
'use strict';

let ELECTIONS = [
  { election_date: "20181106",
    report: "Final Report",
    map: "precincts2017.svg",
    format: 2,
    id: "20181127" },
  { election_date: "20181106",
    report: "Preliminary Report 18",
    map: "precincts2017.svg",
    format: 2,
    id: "20181126" },
  { election_date: "20181106",
    report: "Preliminary Report 17",
    map: "precincts2017.svg",
    format: 2,
    id: "20181120" },
  { election_date: "20181106",
    report: "Preliminary Report 16",
    map: "precincts2017.svg",
    format: 2,
    id: "20181119" },
  { election_date: "20181106",
    report: "Preliminary Report 15",
    map: "precincts2017.svg",
    format: 2,
    id: "20181117" },
  { election_date: "20181106",
    report: "Preliminary Report 14",
    map: "precincts2017.svg",
    format: 2,
    id: "20181116" },
  { election_date: "20181106",
    report: "Preliminary Report 13",
    map: "precincts2017.svg",
    format: 2,
    id: "20181115" },
  { election_date: "20181106",
    report: "Preliminary Report 12",
    map: "precincts2017.svg",
    format: 2,
    id: "20181114" },
  { election_date: "20181106",
    report: "Preliminary Report 11",
    map: "precincts2017.svg",
    format: 2,
    id: "20181113" },
  { election_date: "20181106",
    report: "Preliminary Report 10",
    map: "precincts2017.svg",
    format: 2,
    id: "20181112" },
  { election_date: "20181106",
    report: "Preliminary Report 9",
    map: "precincts2017.svg",
    format: 2,
    id: "20181111" },
  { election_date: "20181106",
    report: "Preliminary Report 8",
    map: "precincts2017.svg",
    format: 2,
    id: "20181110" },
  { election_date: "20181106",
    report: "Preliminary Report 7",
    map: "precincts2017.svg",
    format: 2,
    id: "20181109" },
  { election_date: "20181106",
    report: "Preliminary Report 6",
    map: "precincts2017.svg",
    format: 2,
    id: "20181108" },
  { election_date: "20181106",
    report: "Preliminary Report 5",
    map: "precincts2017.svg",
    format: 2,
    id: "20181107" },
  { election_date: "20181106",
    report: "Preliminary Report 4",
    map: "precincts2017.svg",
    format: 2,
    id: "20181106_4" },
  { election_date: "20181106",
    report: "Preliminary Report 1",
    map: "precincts2017.svg",
    format: 2,
    id: "20181106_1" },
  { election_date: "20180605",
    report: "Final Report",
    map: "precincts2017.svg",
    format: 2,
    id: "20180627" },
  { election_date: "20180605",
    report: "Preliminary Report 16",
    map: "precincts2017.svg",
    format: 2,
    id: "20180621" },
  { election_date: "20180605",
    report: "Preliminary Report 15",
    map: "precincts2017.svg",
    format: 2,
    id: "20180618" },
  { election_date: "20180605",
    report: "Preliminary Report 14",
    map: "precincts2017.svg",
    format: 2,
    id: "20180615" },
  { election_date: "20180605",
    report: "Preliminary Report 13",
    map: "precincts2017.svg",
    format: 2,
    id: "20180614" },
  { election_date: "20180605",
    report: "Preliminary Report 12",
    map: "precincts2017.svg",
    format: 2,
    id: "20180613" },
  { election_date: "20180605",
    report: "Preliminary Report 11",
    map: "precincts2017.svg",
    format: 2,
    id: "20180612" },
  { election_date: "20180605",
    report: "Preliminary Report 10",
    map: "precincts2017.svg",
    format: 2,
    id: "20180611" },
  { election_date: "20180605",
    report: "Preliminary Report 9",
    map: "precincts2017.svg",
    format: 2,
    id: "20180610" },
  { election_date: "20180605",
    report: "Preliminary Report 8",
    map: "precincts2017.svg",
    format: 2,
    id: "20180609" },
  { election_date: "20180605",
    report: "Preliminary Report 7",
    map: "precincts2017.svg",
    format: 2,
    id: "20180608" },
  { election_date: "20180605",
    report: "Preliminary Report 6",
    map: "precincts2017.svg",
    format: 2,
    id: "20180607" },
  { election_date: "20180605",
    report: "Preliminary Report 5",
    map: "precincts2017.svg",
    format: 2,
    id: "20180606" },
  { election_date: "20180605",
    report: "Preliminary Report 4",
    map: "precincts2017.svg",
    format: 2,
    id: "20180605_4" },
  { election_date: "20180605",
    report: "Preliminary Report 1",
    map: "precincts2017.svg",
    format: 2,
    id: "20180605_1" },
  { election_date: "20161108",
    report: "Final Report",
    map: "precincts2012.svg",
    format: 2,
    id: "20161206" },
  { election_date: "20151103",
    report: "Final Report",
    map: "precincts2012.svg",
    format: 2,
    id: "20151119" },
  /* below IDs are mine, not from the Department of Elections */
  { election_date: "20141104",
    report: "Final Report",
    map: "precincts2012.svg",
    format: 2,
    id: "20141104" },
  { election_date: "20121106",
    contest_name: "Board of Supervisors, District 5",
    contest_id: "0000022",
    report: "Final Report",
    map: "precincts2012.svg",
    format: 2,
    id: "20121106_d5" },
  { election_date: "20121106",
    contest_name: "Board of Supervisors, District 7",
    contest_id: "0000023",
    report: "Final Report",
    map: "precincts2012.svg",
    format: 2,
    id: "20121106_d7" },
  { election_date: "20111108",
    contest_name: "Mayor",
    contest_id: "0000003",
    report: "Final Report",
    map: "precincts2002.svg",
    format: 2,
    id: "20111108_mayor" },
  { election_date: "20111108",
    contest_name: "District Attorney",
    contest_id: "0000001",
    report: "Final Report",
    map: "precincts2002.svg",
    format: 2,
    id: "20111108_da" },
  { election_date: "20111108",
    contest_name: "Sheriff",
    contest_id: "0000002",
    report: "Final Report",
    map: "precincts2002.svg",
    format: 2,
    id: "20111108_sheriff" },
  { election_date: "20101102",
    contest_name: "Board of Supervisors, District 2",
    contest_id: "0000007",
    report: "Final Report",
    map: "precincts2002.svg",
    format: 2,
    id: "20101102_d2" },
  { election_date: "20101102",
    contest_name: "Board of Supervisors, District 6",
    contest_id: "0000009",
    report: "Final Report",
    map: "precincts2002.svg",
    format: 2,
    id: "20101102_d6" },
  { election_date: "20101102",
    contest_name: "Board of Supervisors, District 8",
    contest_id: "0000010",
    report: "Final Report",
    map: "precincts2002.svg",
    format: 2,
    id: "20101102_d8" },
  { election_date: "20101102",
    contest_name: "Board of Supervisors, District 10",
    contest_id: "0000006",
    report: "Final Report",
    map: "precincts2002.svg",
    format: 2,
    id: "20101102_d10" },
  { election_date: "20081104",
    report: "Final Report",
    map: "precincts2002.svg",
    format: 2,
    id: "20081202" },
];

var gDefaults = {
    election: ELECTIONS[0].id,
    filters: [],
};
function gethash() {
    var hash = {};
    if (window.location.hash != "") {
        try {
            hash = JSON.parse(unescape(window.location.hash.substring(1)));
        } catch(ex) {}
    }
    for (var prop in gDefaults) {
        if (!(prop in hash)) {
            hash[prop] = gDefaults[prop];
        }
    }
    return hash;
}

function sethash(json) {
    let newhash = escape(JSON.stringify(json));
    if (window.location.hash != newhash) {
        window.location.hash = newhash;
    }
}

var gState;
var gCandidatesRanked;
var gRounds;

let MONTHS = [
  "January",
  "February",
  "March",
  "April",
  "May",
  "June",
  "July",
  "August",
  "September",
  "October",
  "November",
  "December"
];

function dom_load_handler() {
    gState = gethash();

    let elections_select = document.getElementById("election");
    for (let election of ELECTIONS) {
        if (elections_select.lastChild &&
            elections_select.lastChild.getAttribute("value") == election.election_date) {
            continue;
        }
        let option = document.createElement("option");
        option.textContent = `${MONTHS[Number(election.election_date.substr(4,2)) - 1]} ${Number(election.election_date.substr(6,2))}, ${election.election_date.substr(0,4)} Election`;
        option.setAttribute("value", election.election_date);
        elections_select.appendChild(option);
    }
    elections_select.value = gState.election;
    elections_select.addEventListener("change", function elections_select_change(event) {
        if (should_suppress_change(elections_select)) {
            return;
        }
        let election_date = elections_select.value;
        for (let election of ELECTIONS) {
            if (election.election_date == election_date) {
                gState.election = election.id;
                break;
            }
        }
        state_changed();
    });

    let report_select = document.getElementById("report");
    report_select.addEventListener("change", function report_select_change(event) {
        if (should_suppress_change(report_select)) {
            return;
        }
        let election_date = get_current_election().election_date;
        let report = report_select.value;
        for (let election of ELECTIONS) {
            if (election.election_date == election_date &&
                election.report == report) {
                gState.election = election.id;
                break;
            }
        }
        state_changed();
    });

    let contest_select = document.getElementById("contest");
    contest_select.addEventListener("change", function contest_select_change(event) {
        if (should_suppress_change(contest_select)) {
            return;
        }
        gState.contest = contest_select.value;
        let election = get_current_election();
        if ("contest_id" in election) {
            for (let e of ELECTIONS) {
                if (e.election_date == election.election_date &&
                    e.report == election.report &&
                    e.contest_id == gState.contest) {
                    gState.election = e.id;
                    break;
                }
            }
        }
        state_changed();
    });

    document.getElementById("map").addEventListener("load", function map_load(event) {
        update_ui();
    }, {once: true});

    hashchange_listener();
}

function hashchange_listener() {
    gState = gethash();
    sethash(gState);
    update_ui();
}

function state_changed() {
    sethash(gState);
    update_ui();
}

window.addEventListener("DOMContentLoaded", dom_load_handler);
window.addEventListener("hashchange", hashchange_listener);

function get_current_election() {
    return ELECTIONS.find((election) => election.id == gState.election);
}

function* generate_lines(str)
{
    let index = 0;
    while (true) {
        let next = str.indexOf("\n", index);
        if (next == -1) {
            break;
        }
        yield str.slice(index, next);
        index = next + 1;
    }
    return str.slice(index);
}

function read_fields(election_id)
{
    return fetch(new Request(`data/${election_id}_masterlookup.txt`)).then(function fields_load(response) {
        return response.text();
    }).then(function fields_load_text(text) {
        let fields = {};
        for (let line of generate_lines(text)) {
            let type = line.slice(0, 10).trimRight().toLowerCase().replace(" ", "_") + "s";
            let id = line.slice(10, 17);
            let name = line.slice(17, 67).trimRight();
            let order = line.slice(67, 74);
            let candidate_contest = line.slice(74, 81);
            let writein = line.slice(81, 82);
            let provisional = line.slice(82, 83);
            if (!(type in fields)) {
                fields[type] = {};
            }
            let field = fields[type];
            if (type == "candidates") {
                field[id] = { name, order, contest: candidate_contest, writein }
            } else {
                if (candidate_contest != "0000000") {
                    console.log("unexpected candidate_contest", line, candidate_contest);
                }
                if (writein != "0") {
                    console.log("unexpected writein", line, writein);
                }
                field[id] = { name, order }
            }
            if (provisional != "0") {
                console.log("unexpected provisional", line, provisional);
            }
        }
        return fields;
    });
}

function read_ballots(election_id) {
    return fetch(new Request(`data/${election_id}_ballotimage.txt`)).then(function ballots_load(response) {
        return response.text();
    }).then(function ballots_load_text(text) {
        function* generate_ballot_singles(text) {
            for (let line of generate_lines(text)) {
                let contest = line.slice(0, 7);
                let voter = line.slice(7, 16);
                let machine_serial_number = line.slice(16, 23);
                let tally_type = line.slice(23, 26);
                let precinct = line.slice(26, 33);
                let vote_rank = line.slice(33, 36);
                let candidate = line.slice(36, 43);
                let overvote = line.slice(43, 44);
                let undervote = line.slice(44, 45);
                let elimination_round = Number.MAX_SAFE_INTEGER;
                yield {contest, voter, machine_serial_number, tally_type, precinct,
                       vote_rank, candidate, overvote, undervote, elimination_round };
            }
        }
        function* generate_ballot_triples(text) {
            // Assume that the data file has the three ranks for each ballot in order,
            // and report errors if that's not the case, since we don't handle it.
            let gen = generate_ballot_singles(text);
            while (true) {
                let b1 = gen.next();
                let b2 = gen.next();
                let b3 = gen.next();
                if (b1.done) {
                    return;
                }
                if (b3.done) {
                    // These exceptions don't produce useful diagnostics (nothing on console)!
                    console.log("last triple truncated");
                    throw "bad ballot data: last triple truncated";
                }
                b1 = b1.value;
                b2 = b2.value;
                b3 = b3.value;
                const common_props = [ "contest", "voter", "machine_serial_number", "tally_type", "precinct" ];
                let ballot = {};
                for (let prop of common_props) {
                    if (b1[prop] != b2[prop] || b1[prop] != b3[prop]) {
                        // These exceptions don't produce useful diagnostics (nothing on console)!
                        console.log("inconsistent data within ballot");
                        throw "inconsistent data within ballot";
                    }
                    ballot[prop] = b1[prop];
                }
                if (b1.vote_rank != "001" || b2.vote_rank != "002" || b3.vote_rank != "003") {
                    // These exceptions don't produce useful diagnostics (nothing on console)!
                    console.log("ranks throwing", b1.vote_rank, b2.vote_rank, b3.vote_rank);
                    throw "ballot not ranked properly";
                }
                ballot.ranks = [b1, b2, b3].map(b => ({ candidate: b.candidate,
                                                        overvote:  b.overvote,
                                                        undervote: b.undervote }));
                yield ballot;
            }
        }
        return Array.from(generate_ballot_triples(text));
    });
}

function read_format3_data(election_id) {
    return fetch(new Request(`data/${election_id}.json`)).then(function data_load(response) {
        return response.json();
    }).then(function check_json(json) {
        // Check that the ballots always (a) have the ranks in order and
        // (b) don't have duplicate ranks.  There are ballots with ranks
        // missing (e.g., a ballot with ranks 1 and 3).  (FIXME: It's
        // not clear to me what happens if the voter writes duplicate
        // ranks, but those don't seem to show up here, yet anyway.)
        for (let ballot of json.ballots) {
            let ranks = ballot.ranks;
            let last_rank = 0;
            for (let rank of ranks) {
                if (rank.rank <= last_rank) {
                    throw "Found unexpected ballot ranks: " + ballot;
                }
                last_rank = rank.rank;
            }
        }

        return json;
    });
}

function start_needed_loads(election)
{
    if (election.format == 2) {
        if (!("fields" in election)) {
            election.fields = "loading";
            read_fields(election.id).then(function fields_success(fields) { election.fields = fields; update_ui(); }).catch(function fields_failure(error) { console.log(error); delete election.fields; });
        }

        if (!("ballots" in election)) {
            election.ballots = "loading";
            read_ballots(election.id).then(function ballots_success(ballots) { election.ballots = ballots; update_ui(); }).catch(function ballots_error(error) { console.log(error); delete election.ballots; });
        }
    } else if (election.format == 3) {
        if (!("fields" in election)) {
            election.fields = "loading";
            read_format3_data(election.id).then(function data_success(data) { election.fields = data; election.ballots = data.ballots; update_ui(); }).catch(function data_error(error) { console.log(error); delete election.fields; delete election.ballots; });
        }
    }
}

function set_suppress_change(select_element, do_suppress) {
    if (do_suppress) {
        select_element.setAttribute("data-suppress-change", "true");
    } else {
        select_element.removeAttribute("data-suppress-change");
    }
}

function should_suppress_change(select_element) {
    return select_element.hasAttribute("data-suppress-change");
}

function precincts_to_sup_districts(fields, election_id, election_map)
{
    const year = Number(election_id.substr(0, 4));
    if (year < 1970 || year > 2100) {
        throw `Unexpected year ${year}`;
    }
    const map = new Map();
    for (const precinct_id in fields.precincts) {
        let precinct = fields.precincts[precinct_id].name;

        if (!(/^P[Cc][Tt] [0-9]{4}/.exec(precinct))) {
            throw `Unexpected precinct: ${precinct}`;
        }
        precinct = precinct.slice(4);
        let sup_district;
        if ((election_map == "precincts2002.svg")
            ? (precinct[0] == "2" || precinct[0] == "3")
            : (precinct[0] == "7" || precinct[0] == "9")) {
            if (precinct[1] == 0) {
                sup_district = "10";
            } else {
                sup_district = precinct[1];
            }
        } else if (precinct[0] == "1" && precinct[1] == "1") {
            sup_district = "11";
        } else {
            throw `Unexpected precinct: ${precinct}`;
        }
        map.set(precinct_id, sup_district);
    }
    return map;
}

function CandidateData(id, candidates_eliminated) {
    this.id = id;
    this.votes = 0;
    this.votes_by_rank = [];
    this.candidates_eliminated = candidates_eliminated;
    this.transfers_from_recent = candidates_eliminated.reduce((o, id) => Object.assign(o, {[id]: 0}), {});
    this.transfers_from_first = candidates_eliminated.reduce((o, id) => Object.assign(o, {[id]: 0}), {});
    this.precinct_votes = {};
}

CandidateData.prototype.receive_vote = function CandidateData_receive_vote(ranks) {
    ++this.votes;

    let this_id = this.id;
    let receiving_rank = ranks.findIndex((rank) => rank.candidate == this_id);
    while (this.votes_by_rank.length <= receiving_rank) {
        this.votes_by_rank.push(0);
    }
    // NOTE: In format 3, if a ballot has ranks 1 and 3, this counts the
    // 3 as a 2, as it probably should.  But note that in format 2 it
    // doesn't do that since there will be an empty rank.
    ++this.votes_by_rank[receiving_rank];

    // Note that this code needs to be careful to handle both format 2
    // (which can have gaps in the ranks) and format 3 (which can have
    // an arbitrary number of them).
    if (receiving_rank > 0) {
        let higher_candidates = ranks.slice(0, receiving_rank).map((rank) => rank.candidate).filter((id) => id != "0000000");
        if (higher_candidates.length > 0) {
            let higher_candidates_set = new Set(higher_candidates);
            let last_eliminated;

            for (let i = this.candidates_eliminated.length; i-- != 0; ) {
                let candidate = this.candidates_eliminated[i];
                if (higher_candidates_set.has(candidate)) {
                    last_eliminated = candidate;
                    break;
                }
            }
            ++this.transfers_from_recent[last_eliminated];
            ++this.transfers_from_first[higher_candidates[0]]
        }
    }
}

CandidateData.prototype.valueOf = function CandidateData_valueOf() {
    return this.votes;
}

function update_ui() {
    let election = get_current_election();

    let elections_select = document.getElementById("election");
    if (elections_select.value != election.election_date) {
        set_suppress_change(elections_select, true);
        elections_select.value = election.election_date;
        set_suppress_change(elections_select, false);
    }

    start_needed_loads(election);

    let mapObject = document.getElementById("map");
    if (mapObject.getAttribute("data") != election.map) {
        mapObject.setAttribute("data", election.map);
    }

    let contest_output = document.getElementById("contest-output");
    let report_select = document.getElementById("report");
    let contest_select = document.getElementById("contest");
    let state_container = document.getElementById("state-container");

    if (report_select.getAttribute("data-election") != election.election_date) {
        set_suppress_change(report_select, true);
        report_select.textContent = "";
        for (let e of ELECTIONS) {
            if (e.election_date != election.election_date) {
                continue;
            }
            if (report_select.lastChild &&
                report_select.lastChild.getAttribute("value") == e.report) {
                continue;
            }
            let option = document.createElement("option");
            option.textContent = e.report;
            option.setAttribute("value", e.report);
            report_select.appendChild(option);
        }
        report_select.value = election.report;
        set_suppress_change(report_select, false);
        report_select.setAttribute("data-election", election.election_date);
    }

    let report_string = election.election_date + election.report;

    if (contest_select.getAttribute("data-election") != report_string &&
        ("contest_id" in election)) {
        contest_select.setAttribute("data-election", report_string);
        set_suppress_change(contest_select, true);
        contest_select.textContent = "";

        let found = false;
        for (let e of ELECTIONS) {
            if (e.election_date != election.election_date ||
                e.report != election.report) {
                continue;
            }
            let contest_option = document.createElement("option");
            contest_option.textContent = e.contest_name;
            contest_option.value = e.contest_id;
            if (e.contest_id == gState.contest) {
                found = true;
            }
            contest_select.appendChild(contest_option);
        }
        if (!found) {
            gState.contest = contest_select.firstChild.value;
        }
        contest_select.value = gState.contest;
        set_suppress_change(contest_select, false);
    }

    if (election.fields == "loading" || election.ballots == "loading") {
        contest_output.textContent = "Loading...";

        if (!("contest_id" in election)) {
            set_suppress_change(contest_select, true);
            contest_select.textContent = "";
            let contest_option = document.createElement("option");
            contest_option.textContent = "Loading...";
            contest_select.appendChild(contest_option);
            contest_select.removeAttribute("data-election");
            set_suppress_change(contest_select, false);
        }

        state_container.style.display = "none";

        return;
    }

    state_container.style.display = "";

    if (contest_select.getAttribute("data-election") != report_string &&
        !("contest_id" in election)) {
        contest_select.setAttribute("data-election", report_string);
        set_suppress_change(contest_select, true);
        contest_select.textContent = "";
        let contests = election.fields.contests;
        let found = false;
        for (let contest in contests) {
            let contest_option = document.createElement("option");
            contest_option.textContent = contests[contest].name;
            contest_option.value = contest;
            if (contest == gState.contest) {
                found = true;
            }
            contest_select.appendChild(contest_option);
        }
        if (!found) {
            gState.contest = Object.keys(contests)[0];
        }
        contest_select.value = gState.contest;
        set_suppress_change(contest_select, false);
    }

    let contest = contest_select.value;
    let filters_string = JSON.stringify(gState.filters);

    // Only regenerate the contents of contest_output if we need to, based on
    // caching the state we used.
    if (contest_output.getAttribute("data-election") != election.id ||
        contest_output.getAttribute("data-contest") != contest ||
        contest_output.getAttribute("data-filters-string") != filters_string) {

        contest_output.setAttribute("data-election", election.id);
        contest_output.setAttribute("data-contest", contest);
        contest_output.setAttribute("data-filters-string", filters_string);

        let sup_districts = new Map();
        let tally_types = new Map();
        const precinct_to_sup_district_map = precincts_to_sup_districts(election.fields, election.id, election.map);
        for (let ballot of election.ballots) {
            if (ballot.contest != contest) {
                continue;
            }
            let district = precinct_to_sup_district_map.get(ballot.precinct);
            if (district == null) {
                throw Error("precinct_to_sup_district_map could not find " + ballot.precinct)
            }
            sup_districts.set(district, (sup_districts.get(district) || 0) + 1);
            let tally_type = ballot.tally_type;
            tally_types.set(tally_type, (tally_types.get(tally_type) || 0) + 1);
        }

        let contest_candidates = Object.entries(election.fields.candidates).filter(([id, candidate]) => candidate.contest == contest).reduce((o, [id, candidate]) => Object.assign(o, {[id]: Object.assign({id}, candidate)}), {});
        // .map(([id, candidate]) => Object.assign({id}, candidate));
        let candidates_remaining = Object.assign({}, contest_candidates);
        let candidates_eliminated = [];
        let candidates_ranked = [];
        for (let id in candidates_remaining) {
            if (gState.filters.indexOf(`candidate-${id}`) != -1) {
                candidates_ranked.push(Object.assign({id}, candidates_remaining[id]));
                delete candidates_remaining[id];
                // It's important that these removed candidates are *not* in candidates_eliminated,
                // for computing accurate backwards looking data in counterfactual scenarios.
            }
        }

        if ("selected-candidate" in gState &&
            !(gState["selected-candidate"] in contest_candidates)) {
            delete gState["selected-candidate"];
            delete gState["selected-round"];
            sethash(gState);
        }

        let rounds = [];
        const removed_districts = new Set(gState.filters
            .map(x => /^district-d(\d+)$/.exec(x)).filter(m => m != null).map(m => m[1]))
        const removed_tally_types = new Set(gState.filters
            .map(x => /^tally_type-(\d+)$/.exec(x)).filter(m => m != null).map(m => m[1]))
        while (Object.keys(candidates_remaining).length > 1) {
            let ballot_count = 0;
            let round_index = rounds.length;
            let round = Object.keys(candidates_remaining)
                .reduce((o, id) => Object.assign(o, {[id]: new CandidateData(id, candidates_eliminated)}), {});

            // NB: It's very important that these properties are not enumerable!
            Object.defineProperty(round, "overvotes", {
                value: 0,
                enumerable: false,
                writable: true,
            });
            Object.defineProperty(round, "exhausted", {
                value: 0,
                enumerable: false,
                writable: true,
            });
            Object.defineProperty(round, "precinct_votes", {
                value: {},
                enumerable: false,
                writable: true,
            });

            let precinct_map = election.fields.precincts;
            for (let ballot of election.ballots) {
                if (ballot.contest != contest) {
                    continue;
                }

                let district = precinct_to_sup_district_map.get(ballot.precinct);
                if (removed_districts.has(district)) {
                    continue;
                }
                let tally_type = ballot.tally_type;
                if (removed_tally_types.has(ballot.tally_type)) {
                    continue;
                }

                ++ballot_count;
                let overvote = false;
                let used = false;
                for (let rank of ballot.ranks) {
                    if (rank.overvote == "1") {
                        // Discard overvotes, even if a later rank of the ballot is good.
                        // Allow undervotes to fall back to later ranks.
                        overvote = true;
                        break;
                    }
                    if (rank.candidate in round) {
                        let candidate_data = round[rank.candidate];
                        candidate_data.receive_vote(ballot.ranks);
                        let precinct = precinct_map[ballot.precinct].name.substring(4, 8);
                        candidate_data.precinct_votes[precinct] =
                          (candidate_data.precinct_votes[precinct] || 0) + 1;
                        round.precinct_votes[precinct] =
                          (round.precinct_votes[precinct] || 0) + 1;
                        used = true;
                        break;
                    }
                }

                if (!used) {
                    // This ballot was eliminated this round.
                    ballot.elimination_round = round_index;

                    if (overvote) {
                        ++round.overvotes;
                    } else {
                        ++round.exhausted;
                    }
                }
            }
            let lowest_total = Math.min(...Object.values(round));
            // FIXME: This probably isn't right for multiple candidates being eliminated,
            // especially if it eliminates the last one.
            for (let id in candidates_remaining) {
                if (round[id] == lowest_total) {
                    let c = Object.assign({id}, candidates_remaining[id]);
                    candidates_ranked.push(c);
                    delete candidates_remaining[id];
                    candidates_eliminated.push(id);
                }
            }
            rounds.push(round);
        }
        if (Object.keys(candidates_remaining).length == 1) {
            candidates_ranked.push(Object.entries(candidates_remaining).map(([id, candidate]) => Object.assign({id}, candidate))[0]);
        }
        candidates_ranked.reverse();

        if ("selected-round" in gState &&
            !(gState["selected-round"] in rounds)) {
            delete gState["selected-candidate"];
            delete gState["selected-round"];
            sethash(gState);
        }

        if ("selected-round" in gState &&
            "selected-candidate" in gState &&
            !(gState["selected-candidate"] in rounds[gState["selected-round"]])) {
            delete gState["selected-candidate"];
            delete gState["selected-round"];
            sethash(gState);
        }

        gCandidatesRanked = candidates_ranked;
        gRounds = rounds;

        let table = make_rcv_table(candidates_ranked, rounds);
        contest_output.textContent = "";
        contest_output.appendChild(table);

        table.addEventListener("mouseover", function table_mouseover(event) {
            let t = event.target;
            if (t.tagName != "TD" && t.tagName != "TH") {
                return;
            }
            if (t.textContent == "") {
                return;
            }
            let candidate;
            let tr = t.parentNode;
            if (tr.hasAttribute("data-candidate")) {
                candidate = tr.getAttribute("data-candidate");
            }
            set_cell_state(candidate, rcv_cell_to_round(t), "hover");
        });
        table.addEventListener("mouseout", function table_mouseout(event) {
            let t = event.target;
            if (t.tagName != "TD" && t.tagName != "TH") {
                return;
            }
            set_cell_state(undefined, undefined, "hover");
        });

        let filter_container = document.createElement("div");

        let make_filter = (name, set_id, choices, flags) => {
            let filter_div = document.createElement("div");
            filter_div.classList.add("filter");
            filter_div.setAttribute("data-filter", set_id);

            let header_div = document.createElement("div");
            header_div.appendChild(document.createTextNode(`Filter: ${name} `));
            let clear_a = document.createElement("a");
            clear_a.setAttribute("href", `javascript:clear_filters("${set_id}")`);
            clear_a.appendChild(document.createTextNode("clear"));
            header_div.appendChild(document.createTextNode("["));
            header_div.appendChild(clear_a);
            header_div.appendChild(document.createTextNode("]"));
            filter_div.appendChild(header_div);

            for (let choice of choices) {
                let item = document.createElement("div");
                let label = document.createElement("label");
                let checkbox = document.createElement("input");
                checkbox.setAttribute("type", "checkbox");
                let item_id = `${set_id}-${choice.id}`;
                item.setAttribute("data-filter-item", item_id);
                if (gState.filters.indexOf(item_id) == -1) {
                    checkbox.setAttribute("checked", "");
                }
                checkbox.addEventListener("change", (event) => {
                    if (checkbox.checked) {
                        let index = gState.filters.indexOf(item_id);
                        if (index == -1) {
                            console.log(`Unexpectedly couldn't find filter ${item_id}.`);
                        } else {
                            gState.filters.splice(index, 1);
                            state_changed();
                        }
                    } else {
                        gState.filters.push(item_id);
                        state_changed();
                    }
                });
                label.appendChild(checkbox);
                label.appendChild(document.createTextNode(choice.name));
                item.appendChild(label);
                if (flags.only_box) {
                    item.appendChild(document.createTextNode(" "));
                    let a = document.createElement("a");
                    a.setAttribute("href", `javascript:filter_only("${set_id}", "${choice.id}")`);
                    a.appendChild(document.createTextNode("only"));
                    item.appendChild(document.createTextNode("["));
                    item.appendChild(a);
                    item.appendChild(document.createTextNode("]"));
                }
                filter_div.appendChild(item);
            }
            filter_container.appendChild(filter_div);
        };

        make_filter("Supervisor District", "district", Array.from(sup_districts, ([district, count]) => ({ num: Number(district), id: `d${district}`, name: `District ${district} (${count})` })).sort((a, b) => a.num - b.num), { "only_box": true });
        make_filter("Tally Type", "tally_type", Array.from(tally_types, ([tally_type, count]) => ({ id: tally_type, name: `${election.fields.tally_types["0000" + tally_type].name} (${count})` })), { "only_box": true });
        make_filter("Remove Candidates", "candidate", Object.values(contest_candidates).map((candidate) => ({ id: candidate.id, name: candidate.name, order: Number(candidate.order)})).sort((a, b) => a.order - b.order), {});

        contest_output.appendChild(filter_container);
    }

    update_transfers_and_map();
}

function filter_only(set_id, choice_id)
{
    choice_id = `${set_id}-${choice_id}`;
    let container = document.querySelector(`.filter[data-filter="${set_id}"]`);
    for (let item = container.firstChild.nextSibling; item; item = item.nextSibling) {
        let item_id = item.getAttribute("data-filter-item");
        let index = gState.filters.indexOf(item_id);
        if (item_id == choice_id) {
            // Remove the filter-out if it's present.
            if (index != -1) {
                gState.filters.splice(index, 1);
            }
        } else {
            // Add the filter-out if it's not present.
            if (index == -1) {
                gState.filters.push(item_id);
            }
        }
    }
    state_changed();
}

function clear_filters(set_id)
{
    let container = document.querySelector(`.filter[data-filter="${set_id}"]`);
    for (let item = container.firstChild.nextSibling; item; item = item.nextSibling) {
        let item_id = item.getAttribute("data-filter-item");
        let index = gState.filters.indexOf(item_id);
        // Remove the filter-out if it's present.
        if (index != -1) {
            gState.filters.splice(index, 1);
        }
    }
    state_changed();
}

function set_cell_state(candidate, round, state)
{
    let tbody = document.getElementById("rcv_results").firstChild;
    for (let row = tbody.firstElementChild; row; row = row.nextElementSibling) {
        let row_match = candidate !== undefined &&
                        row.getAttribute("data-candidate") == candidate;
        for (let cell = row.firstChild; cell; cell = cell.nextElementSibling) {
            let state_set = row_match &&
                            round !== undefined &&
                            round == rcv_cell_to_round(cell);
            if (state_set) {
                cell.classList.add(state);
            } else {
                cell.classList.remove(state);
            }
        }
    }
}

// from https://svgwg.org/svg2-draft/painting.html#ColorInterpolation
// We will treat srgb as 0-255 but linearrgb as 0-1
function linearrgb_to_srgb(v) {
  let rgb;
  if (v <= 0.04045 / 12.92) {
    rgb = v * 12.92;
  } else {
    rgb = Math.pow(v, 1 / 2.4) * 1.055 - 0.055;
  }
  return rgb * 255;
}

function update_transfers_and_map() {
    let candidates = gCandidatesRanked;
    let transfers = document.getElementById("transfers");
    let round = gState["selected-round"];
    let candidate = gState["selected-candidate"];
    set_cell_state(candidate, round, "selected");
    let mapObject = document.getElementById("map");
    if (round === undefined || candidate === undefined) {
        transfers.textContent = "Click on a cell to learn more";
        mapObject.style.display = "none";
        return;
    }

    transfers.textContent = "";
    let round_data = gRounds[round];
    let votes = round_data[candidate];
    if (!votes) {
        mapObject.style.display = "none";
        return;
    }

    let table = document.createElement("table");
    table.classList.add("transfers");
    let tbody = document.createElement("tbody");
    table.appendChild(tbody);
    let tr_headers = document.createElement("tr");
    tbody.appendChild(tr_headers);
    tr_headers.appendChild(make_cell("th", "Candidate"));
    tr_headers.appendChild(make_cell("th", "Votes transfered from (recent)"));
    tr_headers.appendChild(make_cell("th", "Votes transfered from (first choice)"));

    Object.entries(votes.transfers_from_recent).map(([id, votes]) => ({ id: id, votes: votes }))
        .sort((a, b) => b.votes - a.votes)
        .forEach((transfer) => {
            let tr = document.createElement("tr");
            tbody.appendChild(tr);
            let candidate_name = Object.values(candidates).find((candidate) => candidate.id == transfer.id).name;
            let candidate_cell = make_cell("th", "" + candidate_name);
            let votes_recent_cell = make_cell("td", "" + transfer.votes);
            let votes_first_cell = make_cell("td", "" + votes.transfers_from_first[transfer.id]);
            tr.appendChild(candidate_cell);
            tr.appendChild(votes_recent_cell);
            tr.appendChild(votes_first_cell);
        });

    transfers.appendChild(table);

    mapObject.style.display = "";

    let mapDoc = mapObject.contentDocument;
    if (!mapDoc) {
        return;
    }
    for (let path = mapDoc.documentElement.firstElementChild; path; path = path.nextElementSibling) {
        let precinct = path.id.substr(1);
        if (precinct in round_data.precinct_votes) {
            let portion = (votes.precinct_votes[precinct] || 0) / round_data.precinct_votes[precinct];
            path.style.fill = `rgb(0, 0, ${Math.round(linearrgb_to_srgb(portion))})`;
        } else {
            path.style.fill = "silver";
        }
    }

}


function rcv_cell_to_round(cell) {
    let round;
    if (cell.classList.contains("votes")) {
        round = (cell.cellIndex - 1) / 2;
    } else if (cell.classList.contains("percent")) {
        round = cell.cellIndex / 2 - 1;
    } else if (cell.classList.contains("total")) {
        // for now, don't set state
    }
    return round;
}

function make_cell(tag_name, text)
{
    let cell = document.createElement(tag_name);
    cell.textContent = text;
    return cell;
}

function make_rcv_table(candidates_ranked, rounds)
{
    let rounds_data = rounds.map(round => {
        let max = 0;
        let sum = 0;
        let min = Number.MAX_SAFE_INTEGER;
        for (let votes of Object.values(round)) {
            if (votes > max) {
                max = Number(votes);
            }
            if (votes < min) {
                min = Number(votes);
            }
            sum += votes;
        }
        return {max, min, sum};
    });

    let table = document.createElement("table");
    table.classList.add("rcv_results");
    table.id = "rcv_results";

    let tbody = document.createElement("tbody");

    let tr_header = document.createElement("tr");
    tbody.appendChild(tr_header);
    let candidate_th = make_cell("th", "Candidate");
    tr_header.appendChild(candidate_th);

    for (let round_index in rounds) {
        let round_th = make_cell("th", "" + round_index);
        round_th.classList.add("round");
        round_th.setAttribute("colspan", "2");
        tr_header.appendChild(round_th);
    }

    tbody.addEventListener("click", function tbody_click(event) {
        let target = event.target;
        if (target.tagName != "TD" && target.tagName != "TH") {
            return;
        }
        if (target.textContent == "") {
            return;
        }

        let round = rcv_cell_to_round(target);

        let candidate;
        let tr = target.parentNode;
        if (tr.hasAttribute("data-candidate")) {
            candidate = tr.getAttribute("data-candidate");
        }

        if (round !== undefined && candidate !== undefined) {
            gState["selected-candidate"] = candidate;
            gState["selected-round"] = round;
            state_changed();
        }
    });
    table.appendChild(tbody);
    for (let candidate of candidates_ranked) {
        let tr = document.createElement("tr");
        tr.setAttribute("data-candidate", candidate.id);
        tbody.appendChild(tr);
        let candidate_th = make_cell("th", candidate.name);
        candidate_th.classList.add("candidate");
        if (gState.filters.indexOf(`candidate-${candidate.id}`) != -1) {
            candidate_th.classList.add("candidate-removed");
        }
        tr.appendChild(candidate_th);
        for (let round_index in rounds) {
            let round = rounds[round_index];
            let round_data = rounds_data[round_index];
            let text;
            let votes = 0;
            let in_round = candidate.id in round;
            if (in_round) {
                votes = round[candidate.id];
                text = "" + votes;
            } else {
                text = "";
            }
            let votes_cell = make_cell("td", text);
            let pct_cell = make_cell("td", in_round ? (Math.round(votes / round_data.sum * 10000) / 100) + "%" : "");
            if (votes * 2 > round_data.sum) {
                votes_cell.classList.add("winner");
                pct_cell.classList.add("winner");
            } else if (votes == round_data.max) {
                votes_cell.classList.add("leader");
                pct_cell.classList.add("leader");
            } else if (votes == round_data.min && in_round) {
                votes_cell.classList.add("bubble");
                pct_cell.classList.add("bubble");
            }
            votes_cell.classList.add("votes");
            pct_cell.classList.add("percent");
            tr.appendChild(votes_cell);
            tr.appendChild(pct_cell);
        }
    }
    let tr_sum = document.createElement("tr");
    tbody.appendChild(tr_sum);
    tr_sum.appendChild(make_cell("th", "Total"));
    for (let round_data of rounds_data) {
        let total_cell = make_cell("th", "" + round_data.sum);
        total_cell.classList.add("total");
        total_cell.setAttribute("colspan", "2");
        tr_sum.appendChild(total_cell);
    }

    let tr_overvotes = document.createElement("tr");
    let tr_exhausted = document.createElement("tr");
    tbody.appendChild(tr_overvotes);
    tbody.appendChild(tr_exhausted);
    tr_overvotes.appendChild(make_cell("th", "Overvotes"));
    tr_exhausted.appendChild(make_cell("th", "Exhausted"));
    for (let round of rounds) {
        let overvotes_cell = make_cell("th", "" + round.overvotes);
        overvotes_cell.setAttribute("colspan", "2");
        overvotes_cell.classList.add("total");
        tr_overvotes.appendChild(overvotes_cell);
        let exhausted_cell = make_cell("th", "" + round.exhausted);
        exhausted_cell.classList.add("total");
        exhausted_cell.setAttribute("colspan", "2");
        tr_exhausted.appendChild(exhausted_cell);
    }

    return table;
}

</script>

<body>

<select id="election"></select>
<select id="report"></select>
<select id="contest"></select>

<div id="contest-output"></div>

<div id="state-container" style="display:none">
  <div class="transfer">
    Transfers
    <div id="transfers"></div>
  </div>
  <object type="image/svg+xml" id="map" style="display:none"></object>
</div>

<p>[<a href="https://github.com/dbaron/sf-elections-rcv">source on GitHub</a>]</p>
